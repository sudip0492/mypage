// src/app/api/posts/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import slugify from "slugify";

export async function POST(req: Request) {
  const supabase = createClient();

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { title, content, excerpt, cover_image, status } = await req.json();

  if (!title || !content) {
    return NextResponse.json({ error: "Missing required fields: title and content" }, { status: 400 });
  }

  // --- Slug Generation ---
  let finalSlug = slugify(title, { lower: true, strict: true });
  let isSlugUnique = false;
  let attempt = 0;
  while (!isSlugUnique && attempt < 5) {
    const { data: existingPost, error: checkError } = await supabase
      .from("posts")
      .select("slug")
      .eq("slug", finalSlug)
      .single();
    
    if (checkError && checkError.code !== 'PGRST116') { // 'No rows found' is ok
        console.error("Error checking slug uniqueness:", checkError);
        return NextResponse.json({ error: "Database error while checking slug." }, { status: 500 });
    }

    if (existingPost) {
      const randomString = Math.random().toString(36).substring(2, 8);
      finalSlug = `${slugify(title, { lower: true, strict: true })}-${randomString}`;
      attempt++;
    } else {
      isSlugUnique = true;
    }
  }

  if (!isSlugUnique) {
    return NextResponse.json({ error: "Could not generate a unique slug." }, { status: 500 });
  }

  const postData = {
    author_id: user.id,
    title,
    slug: finalSlug,
    content, // Markdown content
    html: null, // HTML is no longer generated by the editor
    excerpt,
    cover_image,
    status,
    published_at: status === "published" ? new Date().toISOString() : null,
  };

  const { data, error } = await supabase
    .from("posts")
    .insert(postData)
    .select()
    .single();

  if (error) {
    console.error("Error creating post:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(data, { status: 201 });
}
